#' @title Find R packages matching an input of either text or another package
#'
#' @description This function accepts as `input` either a text description, or
#' a path to a local R package, and ranks all R packages within the specified
#' corpus in terms of how well they match that input. The "corpus" argument can
#' specify either [rOpenSci's package suite](https://ropensci.org/packages), or
#' [CRAN](https://cran.r-project.org).
#'
#' Ranks are obtained from scores derived from:
#' \itemize{
#' \item Cosine similarities between Language Model (LM) embeddings for the
#' `input`, and corresponding embeddings for the specified corpus. \item ["Best
#' Match 25" (BM25)](https://en.wikipedia.org/wiki/Okapi_BM25) scores based on
#' document token frequencies.
#' }
#'
#' For text input, ranks are generally obtained for packages both including and
#' excluding function descriptions as part of the package text, giving two sets
#' of ranks for a given input. Where input is an entire R package, separate
#' ranks are also calculated for package code and text, thus giving four
#' distinct ranks. The function ultimately returns a single rank, derived by
#' combining individual ranks using the [Reciprocal Rank Fusion (RRF)
#' algorithm](https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf). The
#' additional parameter of `lm_proportion` determines the extent to which the
#' final ranking weights the LM versus BM25 components.
#'
#' Finally, all components of this function are locally cached for each call
#' (by the \pkg{memoise} package), so additional calls to this function with
#' the same `input` and `corpus` should be much faster than initial calls. This
#' means the effect of changing `lm_proportion` can easily be examined by
#' simply repeating calls to this function.
#'
#' @param input Either a text string, a path to local source code of an R
#' package, or the name of any installed R package.
#' @param corpus Must be specified as one of "ropensci" or "cran". If
#' `embeddings` or `idfs` parameters are not specified, they will be
#' automatically downloaded for the corpus specified by this parameter. The
#' function will then return the most similar package from the specified
#' corpus. Note that calculations will `corpus = "cran"` will generally take
#' longer, because the corpus is much larger.
#' @param embeddings Large Language Model embeddings for a suite of packages,
#' generated from \link{pkgmatch_embeddings_from_pkgs}. If not provided,
#' pre-generated embeddings will be downloaded and stored in a local cache
#' directory.
#' @param idfs Inverse Document Frequency tables for a suite of packages,
#' generated from \link{pkgmatch_bm25}. If not provided, pre-generated IDF
#' tables will be downloaded and stored in a local cache directory.
#' @param input_is_code A binary flag indicating whether `input` is code or
#' plain text. Ignored if `input` is path to a local package; otherwise can be
#' used to force appropriate interpretation of input type.
#' @param lm_proportion A value between 0 and 1 to control the relative
#' contributions of results from Language Models ("LMs") versus results from
#' traditional token-frequency models. Final rankings are generated by
#' combining these two kinds of results, so that `lm_proportion = 0` will
#' return results from token frequency analyses only, while `lm_proportion =
#' 1` will return results from LMs only.
#' @param n When the result of this function is printed to screen, the top `n`
#' packages will be displayed.
#' @param browse If `TRUE`, automatically open webpages of the top `n` matches
#' in local browser.
#'
#' @return A `data.frame` with a "package" column naming packages, and one or
#' more columns of package ranks in terms of text similarity and, if `input` is
#' an R package, of similarity in code structure.
#'
#' The returned object has a default `print` method which prints the best 5
#' matches directly to the screen, yet returns information on all packages
#' within the specified corpus. This information is in the form of a
#' `data.frame`, with one column for the package name, and one or more
#' additional columns of integer ranks for each package. There is also a `head`
#' method to print the first few entries of these full data (default `n = 5`).
#' To see all data, use `as.data.frame()`. See the example below for how to
#' manipulate these objects.
#'
#' @note The first time this function is run without passing either
#' `embeddings` or `idfs`, required values will be automatically downloaded and
#' stored in a locally persistent cache directory. Especially for the "cran"
#' corpus, this downloading may take quite some time.
#'
#' @seealso input_is_code
#'
#' @family main
#' @export
#'
#' @examples
#' # The following function simulates remote data in temporary directory, to
#' # enable package usage without downloading. Do not run for normal usage.
#' generate_pkgmatch_example_data ()
#'
#' input <- "curl" # Name of a single installed package
#' p <- pkgmatch_similar_pkgs (input, corpus = "cran")
#' p # Default print method, lists 5 best matching packages
#' head (p) # Shows first 5 rows of full `data.frame` object
#'
#' # This second call modifies default combining of results equally from language
#' # model and token frequency (BM25) results. It will be much faster than first
#' # call, because previously generated embeddings are re-used.
#' p2 <- pkgmatch_similar_pkgs (input, corpus = "cran", lm_proportion = 0.25)
#'
#' # Example demonstrating how to combine results using different values of
#' # `lm_proportion`. Input is a package, so result has columns for "text_rank"
#' # and "code_rank".
#' lm_props <- 0:10 / 10
#' res <- lapply (lm_props, function (p) {
#'     nm_text <- sprintf ("text_rank_p%02.0f", p * 10)
#'     nm_code <- sprintf ("code_rank_p%02.0f", p * 10)
#'     res <- pkgmatch_similar_pkgs (input, corpus = "cran", lm_proportion = p) |>
#'         dplyr::rename ({{nm_text}} := "text_rank", {{nm_code}} := "code_rank") |>
#'         dplyr::arrange (package)
#'     if (p > 0) {
#'         res <- dplyr::select (res, -package, -version)
#'     }
#'     return (res)
#' })
#' res <- do.call (cbind, res)
#'
#' # That then has paired columns of (text rank, code rank) for each of the
#' # 11 values of `lm_props`.
#' head (res)
pkgmatch_similar_pkgs <- function (input,
                                   corpus = NULL,
                                   embeddings = NULL,
                                   idfs = NULL,
                                   input_is_code = text_is_code (input),
                                   lm_proportion = 0.5,
                                   n = 5L,
                                   browse = FALSE) {

    if (is.null (embeddings) || is.null (idfs)) {
        corpus <- check_corpus_param (corpus)
    }

    checkmate::assert_character (input, len = 1L)
    checkmate::assert_logical (input_is_code, len = 1L)
    checkmate::assert_numeric (lm_proportion, len = 1L, lower = 0, upper = 1)
    checkmate::assert_integerish (n, len = 1L, lower = 1L)
    checkmate::assert_logical (browse, len = 1L)

    use_ollama <- ollama_check_quiet ()
    if (!use_ollama) {
        cli::cli_warn (paste0 (
            "ollama is not available. Matches will be based on word ",
            "frequencies only, and will generally be inferior to results ",
            "enhanced with ollama. Run 'ollama_check()' for diagnostic ",
            "help, or see vvgnette on setting up ollama."
        ))
    }

    code <- NULL # Supress no visible binding note

    fnames <- NULL
    if (is.null (embeddings)) {
        fnames <- c (
            fnames,
            get_cache_file_name (
                what = "embeddings", corpus = corpus, fns = FALSE, raw = FALSE
            )
        )
    }
    if (is.null (idfs)) {
        fnames <- c (
            fnames,
            get_cache_file_name (
                what = "idfs", corpus = corpus, fns = FALSE, raw = FALSE
            )
        )
    }
    if (input_is_pkg (input)) {
        fnames <- c (
            fnames,
            get_cache_file_name (
                what = "calls", corpus = corpus, fns = FALSE, raw = FALSE
            ),
            get_cache_file_name (
                what = "calls", corpus = corpus, fns = FALSE, raw = TRUE
            )
        )
    }
    if (!is.null (fnames)) {
        send_dl_message (fnames)
    }

    if (is.null (embeddings) && use_ollama) {
        embeddings <- pkgmatch_load_data (what = "embeddings", corpus = corpus)
    }
    if (!is.null (embeddings)) {
        # Remains NULL is no ollama
        nms_expected <- c ("text_with_fns", "text_wo_fns", "code")
        checkmate::assert_list (embeddings, len = 3L)
        checkmate::assert_names (names (embeddings), identical.to = nms_expected)
    }

    if (is.null (idfs)) {
        idfs <- pkgmatch_load_data (what = "idfs", corpus = corpus)
        index <- which (!duplicated (names (idfs$token_lists$with_fns)))
        idfs$token_lists$with_fns <- idfs$token_lists$with_fns [index]
        index <- which (!duplicated (names (idfs$token_lists$wo_fns)))
        idfs$token_lists$wo_fns <- idfs$token_lists$wo_fns [index]
    }
    checkmate::assert_list (idfs, len = 2L)
    checkmate::assert_names (
        names (idfs),
        identical.to = c ("idfs", "token_lists")
    )

    if (input_is_pkg (input)) {

        res <- similar_pkgs_from_pkg (input, embeddings)
        if (corpus == "cran") {
            res <- make_cran_version_column (res) # in 'utils.R'
        }

        # Then add BM25 from package text:
        txt_with_fns <- get_pkg_text (input)
        txt_wo_fns <- rm_fns_from_pkg_txt (txt_with_fns) [[1]]
        bm25_with_fns <-
            pkgmatch_bm25 (txt_with_fns, idfs = idfs, corpus = corpus)
        bm25_wo_fns <- pkgmatch_bm25 (txt_wo_fns, idfs = idfs, corpus = corpus)
        # bm25 fn returns measures against idfs with and without fns:
        bm25_with_fns$bm25_wo_fns <- NULL
        bm25_wo_fns$bm25_with_fns <- NULL
        bm25_text <- dplyr::left_join (
            bm25_with_fns,
            bm25_wo_fns,
            by = "package"
        )
        res <- dplyr::left_join (res, bm25_text, by = "package") |>
            dplyr::relocate (code, .after = dplyr::last_col ())

        # Then combine BM25 from function calls with "code" similarities:
        bm25_code <- pkgmatch_bm25_fn_calls (input, corpus = corpus) |>
            dplyr::rename (bm25_code = "bm25")

        res <- dplyr::left_join (res, bm25_code, by = "package")

        rm_fn_data <- TRUE # TODO: Expose that parameter

    } else {

        res <- similar_pkgs_from_text (
            input = input,
            embeddings = embeddings,
            idfs = idfs,
            corpus = corpus,
            input_is_code = input_is_code,
            use_ollama = use_ollama
        )
        if (identical (corpus, "cran") ||
            all (grepl ("\\_[0-9]", res$package))) {
            res <- make_cran_version_column (res)
        }

        rm_fn_data <- !input_mentions_functions (input)

    }

    res <- pkgmatch_rerank (res, rm_fn_data, lm_proportion)

    class (res) <- c ("pkgmatch", class (res))
    attr (res, "n") <- as.integer (n)

    if (browse) {
        pkgmatch_browse (res) # nocov
    }

    return (res)
}

similar_pkgs_from_pkg <- function (input, embeddings) {

    m_similar_pkgs_from_pkg (input, embeddings)
}

similar_pkgs_from_pkg_internal <- function (input, embeddings) {

    op <- getOption ("rlib_message_verbosity")
    options (rlib_message_verbosity = "quiet")

    emb <- pkgmatch_embeddings_from_pkgs (input)

    options ("rlib_message_verbosity" = op)

    d_text <- lapply (
        c ("text_with_fns", "text_wo_fns"),
        function (what) {
            npkgs <- ncol (embeddings [[what]])
            nrow <- nrow (emb [[what]])
            d_text_this <- cosine_similarity (
                emb [[what]],
                embeddings [[what]],
                fns = FALSE
            )
            names (d_text_this) [2] <- what
            return (d_text_this)
        }
    )
    d_text <- dplyr::left_join (d_text [[1]], d_text [[2]], by = "package")

    d_code <- cosine_similarity (emb$code, embeddings$code, fns = FALSE)
    names (d_code) [2] <- "code"

    out <- dplyr::left_join (d_text, d_code, by = "package")
    out$code <- out$code / max (out$code, na.rm = TRUE)
    out$text_with_fns <-
        out$text_with_fns / max (out$text_with_fns, na.rm = TRUE)
    out$text_wo_fns <- out$text_wo_fns / max (out$text_wo_fns, na.rm = TRUE)

    return (out)
}
m_similar_pkgs_from_pkg <- memoise::memoise (similar_pkgs_from_pkg_internal)

order_output <- function (out, what = "text") {

    index <- order (out [[what]])
    out <- out [index, c ("package", what)]
    rownames (out) <- NULL

    return (out)
}

similar_pkgs_from_text <- function (input,
                                    embeddings = NULL,
                                    idfs = NULL,
                                    corpus = NULL,
                                    input_is_code = text_is_code (input),
                                    use_ollama = TRUE) {

    # Suppress no visible binding note
    package <- NULL

    stopifnot (is.character (input))
    stopifnot (length (input) == 1L)

    similarities_bm25 <-
        pkgmatch_bm25 (input = input, idfs = idfs, corpus = corpus) |>
        dplyr::mutate (package = gsub ("\\.tar\\.gz$", "", package))

    if (is.null (embeddings) && use_ollama) {
        embeddings <- pkgmatch_load_data (what = "embeddings", corpus = corpus)
    }

    if (use_ollama) {

        if (input_is_code) {
            similarities <- similarity_embeddings (
                input,
                embeddings$code,
                input_is_code = TRUE
            )
        } else {
            similarities <- similarity_embeddings (
                input,
                embeddings,
                input_is_code = FALSE
            )
        }

    } else {

        similarities <- data.frame (
            package = similarities_bm25$package,
            simil_with_fns = NA_character_,
            simil_to_fns = NA_character_
        )

    }

    similarities <- dplyr::left_join (
        similarities,
        similarities_bm25,
        by = "package"
    )

    similarities [is.na (similarities)] <- 0

    return (similarities)
}

input_mentions_functions <- function (input) {

    stopifnot (length (input) == 1L)

    grepl ("\\bfunction(s)?\\b", input, ignore.case = TRUE)
}
