% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/similar-pkgs.R
\name{pkgmatch_similar_pkgs}
\alias{pkgmatch_similar_pkgs}
\title{Find R packages matching an input of either text or another package}
\usage{
pkgmatch_similar_pkgs(
  input,
  corpus = NULL,
  embeddings = NULL,
  idfs = NULL,
  input_is_code = text_is_code(input),
  lm_proportion = 0.5,
  n = 5L,
  browse = FALSE
)
}
\arguments{
\item{input}{Either a text string, a path to local source code of an R
package, or the name of any installed R package.}

\item{corpus}{Must be specified as one of "ropensci" or "cran". If
\code{embeddings} or \code{idfs} parameters are not specified, they will be
automatically downloaded for the corpus specified by this parameter. The
function will then return the most similar package from the specified
corpus. Note that calculations will \code{corpus = "cran"} will generally take
longer, because the corpus is much larger.}

\item{embeddings}{Large Language Model embeddings for a suite of packages,
generated from \link{pkgmatch_embeddings_from_pkgs}. If not provided,
pre-generated embeddings will be downloaded and stored in a local cache
directory.}

\item{idfs}{Inverse Document Frequency tables for a suite of packages,
generated from \link{pkgmatch_bm25}. If not provided, pre-generated IDF
tables will be downloaded and stored in a local cache directory.}

\item{input_is_code}{A binary flag indicating whether \code{input} is code or
plain text. Ignored if \code{input} is path to a local package; otherwise can be
used to force appropriate interpretation of input type.}

\item{lm_proportion}{A value between 0 and 1 to control the relative
contributions of results from Language Models ("LMs") versus results from
traditional token-frequency models. Final rankings are generated by
combining these two kinds of results, so that \code{lm_proportion = 0} will
return results from token frequency analyses only, while \code{lm_proportion = 1} will return results from LMs only.}

\item{n}{When the result of this function is printed to screen, the top \code{n}
packages will be displayed.}

\item{browse}{If \code{TRUE}, automatically open webpages of the top \code{n} matches
in local browser.}
}
\value{
A \code{data.frame} with a "package" column naming packages, and one or
more columns of package ranks in terms of text similarity and, if \code{input} is
an R package, of similarity in code structure.

The returned object has a default \code{print} method which prints the best 5
matches directly to the screen, yet returns information on all packages
within the specified corpus. This information is in the form of a
\code{data.frame}, with one column for the package name, and one or more
additional columns of integer ranks for each package. There is also a \code{head}
method to print the first few entries of these full data (default \code{n = 5}).
To see all data, use \code{as.data.frame()}. See the example below for how to
manipulate these objects.
}
\description{
This function accepts as \code{input} either a text description, or
a path to a local R package, and ranks all R packages within the specified
corpus in terms of how well they match that input. The "corpus" argument can
specify either \href{https://ropensci.org/packages}{rOpenSci's package suite}, or
\href{https://cran.r-project.org}{CRAN}.

Ranks are obtained from scores derived from:
\itemize{
\item Cosine similarities between Language Model (LM) embeddings for the
\code{input}, and corresponding embeddings for the specified corpus. \item \href{https://en.wikipedia.org/wiki/Okapi_BM25}{"Best Match 25" (BM25)} scores based on
document token frequencies.
}

For text input, ranks are generally obtained for packages both including and
excluding function descriptions as part of the package text, giving two sets
of ranks for a given input. Where input is an entire R package, separate
ranks are also calculated for package code and text, thus giving four
distinct ranks. The function ultimately returns a single rank, derived by
combining individual ranks using the \href{https://plg.uwaterloo.ca/~gvcormac/cormacksigir09-rrf.pdf}{Reciprocal Rank Fusion (RRF) algorithm}. The
additional parameter of \code{lm_proportion} determines the extent to which the
final ranking weights the LM versus BM25 components.

Finally, all components of this function are locally cached for each call
(by the \pkg{memoise} package), so additional calls to this function with
the same \code{input} and \code{corpus} should be much faster than initial calls. This
means the effect of changing \code{lm_proportion} can easily be examined by
simply repeating calls to this function.
}
\note{
The first time this function is run without passing either
\code{embeddings} or \code{idfs}, required values will be automatically downloaded and
stored in a locally persistent cache directory. Especially for the "cran"
corpus, this downloading may take quite some time.
}
\examples{
# The following function simulates remote data in temporary directory, to
# enable package usage without downloading. Do not run for normal usage.
generate_pkgmatch_example_data ()

input <- "curl" # Name of a single installed package
p <- pkgmatch_similar_pkgs (input, corpus = "cran")
p # Default print method, lists 5 best matching packages
head (p) # Shows first 5 rows of full `data.frame` object

\dontrun{
input <- "Download open spatial data from NASA"
p <- pkgmatch_similar_pkgs (input)
p # Default print method, lists 5 best matching packages
head (p) # Shows first 5 rows of full `data.frame` object
# This second call will be much faster than first call:
p2 <- pkgmatch_similar_pkgs (input, lm_proportion = 0.25)

# Example demonstrating how to combine results using different values of
# `lm_proportion`. Input is a package, so result has columns for "text_rank"
# and "code_rank".
input <- "cli" # Name of package (if installed)
corpus <- "ropensci"
lm_props <- 0:10 / 10
res <- lapply (lm_props, function (p) {
    nm_text <- sprintf ("text_rank_p\%02.0f", p * 10)
    nm_code <- sprintf ("code_rank_p\%02.0f", p * 10)
    res <- pkgmatch_similar_pkgs (input, corpus = "ropensci", lm_proportion = p) |>
        dplyr::rename ({{nm_text}} := "text_rank", {{nm_code}} := "code_rank") |>
        dplyr::arrange (package)
    if (p > 0) {
        res <- dplyr::select (res, -package)
    }
    return (res)
})
res <- do.call (cbind, res)
# That then has paired columns of (text rank, code rank) for each of the
# 11 values of `lm_props`.
}
}
\seealso{
input_is_code

Other main: 
\code{\link{pkgmatch_similar_fns}()}
}
\concept{main}
